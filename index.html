<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spectrogram Visualizer - Standalone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a0a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            max-width: 300px;
        }

        #controls h2 {
            margin: 0 0 15px 0;
            color: #00ff88;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: inline-block;
            width: 100px;
            font-size: 12px;
        }

        button {
            background: #00ff88;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 2px;
            font-weight: bold;
            color: black;
        }

        button:hover {
            background: #00cc6a;
        }

        button.recording {
            background: #ff4444;
            color: white;
        }

        #spectrum-canvas {
            width: 100%;
            height: 100%;
        }

        .vowel-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .vowel-btn {
            padding: 5px 8px;
            font-size: 11px;
            min-width: 40px;
        }

        #status {
            position: absolute;
            top: 20px;
            right: 760px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            color: white;
            min-width: 300px;
        }

        .formant-info {
            font-size: 12px;
            color: #88ff88;
            margin-top: 5px;
        }

        #canvas2d {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #0a0a0a, #1a1a2e);
        }

        .debug-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff88;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 11px;
        }

        #formant-plot {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 250px;
            height: 200px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff88;
            border-radius: 5px;
            z-index: 1000;
        }

        #formant-plot canvas {
            width: 100%;
            height: 100%;
        }

        #mfcc-plot {
            position: absolute;
            top: 20px;
            right: 280px;
            width: 500px;
            height: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff8844;
            border-radius: 5px;
            z-index: 1000;
        }

        #mfcc-plot canvas {
            width: 100%;
            height: 100%;
        }

        .plot-title {
            position: absolute;
            top: 5px;
            left: 10px;
            color: white;
            font-size: 12px;
            font-weight: bold;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas2d"></canvas>

        <div id="controls">
            <h2>üéØ Audio Spectrogram</h2>

            <div class="control-group">
                <button id="recordBtn">üéôÔ∏è Start Recording</button>
                <button id="resetBtn">Reset</button>
            </div>

            <div class="control-group">
                <label>Target Vowel:</label>
                <div class="vowel-buttons">
                    <button class="vowel-btn" data-vowel="√¶">√¶ (cat)</button>
                    <button class="vowel-btn" data-vowel="…™">…™ (sit)</button>
                    <button class="vowel-btn" data-vowel=" ä"> ä (put)</button>
                    <button class="vowel-btn" data-vowel="…õ">…õ (get)</button>
                    <button class="vowel-btn" data-vowel="…î">…î (caught)</button>
                    <button class="vowel-btn" data-vowel=" å"> å (but)</button>
                    <button class="vowel-btn" data-vowel="…ë">…ë (father)</button>
                    <button class="vowel-btn" data-vowel="…ô">…ô (about)</button>
                </div>
            </div>

        </div>

        <div id="status">
            <div><strong>Status:</strong> <span id="statusText">Click Start Recording</span></div>
            <div><strong>Target:</strong> <span id="targetVowel">√¶ (cat)</span></div>
            <div class="formant-info">
                <strong>Audio Level:</strong> <span id="audioLevel">0</span>
            </div>
            <div class="formant-info">
                <strong>Formants:</strong> F1=<span id="f1Value">-</span>Hz, F2=<span id="f2Value">-</span>Hz
            </div>
            <div class="formant-info">
                <strong>Frequency Peak:</strong> <span id="freqPeak">-</span>Hz
            </div>
            <div class="formant-info">
                <strong>Detected:</strong> <span id="detectedVowel">-</span>
            </div>
        </div>

        <div class="debug-info" id="debugInfo">
            Debug: Ready
        </div>

        <div id="formant-plot">
            <div class="plot-title">Formant Space</div>
            <canvas id="formant-canvas" width="200" height="150"></canvas>
        </div>

        <div id="mfcc-plot">
            <div class="plot-title">MFCC Coefficients</div>
            <canvas id="mfcc-canvas" width="500" height="250"></canvas>
        </div>
    </div>

    <script>
        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        let canvas, ctx;
        let formantCanvas, formantCtx;
        let mfccCanvas, mfccCtx;
        let analyser, microphone, audioContext;
        let animationId;
        let isRecording = false;
        let currentVowel = '√¶';
        let spectrogramData = [];
        let maxSpectrogramHistory = 200;
        let currentMFCC = [];

        // Ëã±Ë™ûÊØçÈü≥„Éá„Éº„ÇøÔºà„Éï„Ç©„É´„Éû„É≥„Éà + MFCCÁêÜÊÉ≥ÂÄ§Ôºâ
        const ENGLISH_VOWELS = {
            '√¶': {
                name: 'cat',
                color: '#8B0000',
                f1: 700,
                f2: 1700,
                mfcc: [12.5, -1.8, -2.3, 1.2, -0.8, 0.5, -0.3, 0.2, -0.1, 0.1, -0.05, 0.02, -0.01]
            },
            '…™': {
                name: 'sit',
                color: '#00008B',
                f1: 400,
                f2: 2000,
                mfcc: [11.8, -0.9, -1.8, 0.8, -0.6, 0.4, -0.2, 0.15, -0.08, 0.05, -0.03, 0.01, -0.005]
            },
            ' ä': {
                name: 'put',
                color: '#006400',
                f1: 400,
                f2: 1000,
                mfcc: [12.2, -2.5, -1.2, 1.5, -1.0, 0.7, -0.4, 0.25, -0.12, 0.08, -0.04, 0.02, -0.01]
            },
            '…õ': {
                name: 'get',
                color: '#800080',
                f1: 550,
                f2: 1800,
                mfcc: [12.0, -1.5, -2.0, 1.0, -0.7, 0.45, -0.25, 0.18, -0.09, 0.06, -0.035, 0.015, -0.008]
            },
            '…î': {
                name: 'caught',
                color: '#FF8C00',
                f1: 550,
                f2: 900,
                mfcc: [12.8, -2.8, -1.0, 1.8, -1.2, 0.8, -0.5, 0.3, -0.15, 0.1, -0.05, 0.025, -0.012]
            },
            ' å': {
                name: 'but',
                color: '#A0522D',
                f1: 600,
                f2: 1200,
                mfcc: [12.3, -2.0, -1.6, 1.3, -0.9, 0.6, -0.35, 0.22, -0.11, 0.07, -0.04, 0.018, -0.009]
            },
            '…ë': {
                name: 'father',
                color: '#800000',
                f1: 750,
                f2: 1100,
                mfcc: [13.0, -2.2, -1.4, 1.6, -1.1, 0.75, -0.45, 0.28, -0.14, 0.09, -0.045, 0.022, -0.011]
            },
            '…ô': {
                name: 'about',
                color: '#808080',
                f1: 500,
                f2: 1500,
                mfcc: [11.5, -1.2, -1.5, 0.9, -0.65, 0.4, -0.22, 0.16, -0.08, 0.05, -0.03, 0.012, -0.006]
            }
        };

        // HSV„Åã„ÇâRGBÂ§âÊèõÔºàChrome Music LabÂÜçÁèæÔºâ
        function hsvToRgb(h, s, v) {
            h = ((h % 360) + 360) % 360; // 0-360„Å´Ê≠£Ë¶èÂåñ
            s = Math.max(0, Math.min(1, s));
            v = Math.max(0, Math.min(1, v));

            const c = v * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = v - c;

            let r, g, b;
            if (h < 60) {
                r = c; g = x; b = 0;
            } else if (h < 120) {
                r = x; g = c; b = 0;
            } else if (h < 180) {
                r = 0; g = c; b = x;
            } else if (h < 240) {
                r = 0; g = x; b = c;
            } else if (h < 300) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }

            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        // ÂàùÊúüÂåñ
        function init() {
            console.log("Initializing...");

            canvas = document.getElementById('canvas2d');
            ctx = canvas.getContext('2d');

            // „Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„ÉàÂàùÊúüÂåñ
            formantCanvas = document.getElementById('formant-canvas');
            formantCtx = formantCanvas.getContext('2d');

            // MFCC„Éó„É≠„ÉÉ„ÉàÂàùÊúüÂåñ
            mfccCanvas = document.getElementById('mfcc-canvas');
            mfccCtx = mfccCanvas.getContext('2d');

            // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫„ÇíË®≠ÂÆö
            resizeCanvas();

            setupEventListeners();

            // „ÉÜ„Çπ„ÉàÊèèÁîª
            drawTestPattern();
            drawFormantPlot();
            drawMFCCPlot();

            console.log("Initialization complete");
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        function drawTestPattern() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // „ÉÜ„Çπ„Éà„Éë„Çø„Éº„É≥ÊèèÁîª
            ctx.fillStyle = '#00ff88';
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Audio Spectrogram Visualizer', canvas.width / 2, canvas.height / 2 - 50);

            ctx.fillStyle = '#888';
            ctx.font = '16px Arial';
            ctx.fillText('Click "Start Recording" to begin', canvas.width / 2, canvas.height / 2);
            ctx.fillText('No external libraries required', canvas.width / 2, canvas.height / 2 + 30);
        }

        async function startAudioCapture() {
            try {
                console.log("Starting audio capture...");
                document.getElementById('debugInfo').textContent = "Debug: Requesting microphone access...";

                // Web Audio APIÂàùÊúüÂåñ
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext state:", audioContext.state);

                // „Éû„Ç§„ÇØ„Ç¢„ÇØ„Çª„ÇπË¶ÅÊ±Ç
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });

                console.log("Microphone access granted");
                document.getElementById('debugInfo').textContent = "Debug: Microphone access granted";

                microphone = audioContext.createMediaStreamSource(stream);

                // „Ç¢„Éä„É©„Ç§„Ç∂„Éº‰ΩúÊàê
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.1;

                microphone.connect(analyser);

                console.log("Audio setup completed");
                document.getElementById('debugInfo').textContent = "Debug: Audio setup complete";

                return true;
            } catch (error) {
                console.error('Audio initialization failed:', error);
                document.getElementById('statusText').textContent = 'Audio Error: ' + error.message;
                document.getElementById('debugInfo').textContent = "Debug: Audio error - " + error.message;
                return false;
            }
        }

        function setupEventListeners() {
            // Èå≤Èü≥„Éú„Çø„É≥
            document.getElementById('recordBtn').addEventListener('click', toggleRecording);


            // ÊØçÈü≥ÈÅ∏Êäû
            document.querySelectorAll('.vowel-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentVowel = btn.dataset.vowel;
                    const vowelData = ENGLISH_VOWELS[currentVowel];
                    document.getElementById('targetVowel').textContent =
                        `${currentVowel} (${vowelData.name})`;

                    // „Éó„É≠„ÉÉ„ÉàÊõ¥Êñ∞
                    drawFormantPlot();
                    drawMFCCPlot();

                    console.log(`Target vowel changed to: ${currentVowel}`);
                });
            });


            // „É™„Çª„ÉÉ„Éà
            document.getElementById('resetBtn').addEventListener('click', () => {
                spectrogramData = [];
                drawTestPattern();
            });

            // „Ç¶„Ç£„É≥„Éâ„Ç¶„É™„Çµ„Ç§„Ç∫
            window.addEventListener('resize', resizeCanvas);
        }

        async function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            console.log("Toggle recording, current state:", isRecording);

            if (!isRecording) {
                // Èå≤Èü≥ÈñãÂßã
                document.getElementById('statusText').textContent = 'Initializing...';

                const success = await startAudioCapture();
                if (!success) {
                    return;
                }

                isRecording = true;
                btn.textContent = '‚èπÔ∏è Stop Recording';
                btn.classList.add('recording');
                document.getElementById('statusText').textContent = 'Recording...';

                // AudioContext„ÇíÂÜçÈñã
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÈñãÂßã
                animate();

            } else {
                // Èå≤Èü≥ÂÅúÊ≠¢
                isRecording = false;
                btn.textContent = 'üéôÔ∏è Start Recording';
                btn.classList.remove('recording');
                document.getElementById('statusText').textContent = 'Stopped';

                // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥ÂÅúÊ≠¢
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }

                // „Çπ„Éà„É™„Éº„É†ÂÅúÊ≠¢
                if (microphone && microphone.mediaStream) {
                    microphone.mediaStream.getTracks().forEach(track => track.stop());
                }
            }
        }


        function animate() {
            if (!isRecording) return;

            animationId = requestAnimationFrame(animate);

            updateSpectrogram();
            drawSpectrogram();
        }

        function updateSpectrogram() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Èü≥Â£∞„É¨„Éô„É´Ë®àÁÆó
            let sum = 0;
            let maxVal = 0;
            let maxIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
                if (dataArray[i] > maxVal) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            const avgLevel = Math.round(sum / bufferLength);
            const peakFreq = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));

            // UIÊõ¥Êñ∞
            document.getElementById('audioLevel').textContent = avgLevel;
            document.getElementById('freqPeak').textContent = peakFreq;
            document.getElementById('debugInfo').textContent =
                `Debug: Level=${avgLevel}, Peak=${peakFreq}Hz, Max=${maxVal}`;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†„Éá„Éº„Çø„Å´ËøΩÂä†
            spectrogramData.push(Array.from(dataArray));

            // Â±•Ê≠¥Âà∂Èôê
            if (spectrogramData.length > maxSpectrogramHistory) {
                spectrogramData.shift();
            }

            // Á∞°ÊòìÊØçÈü≥ÂàÜÈ°û
            classifyVowel(dataArray);
        }

        function drawSpectrogram() {
            if (spectrogramData.length === 0) return;

            const width = canvas.width;
            const height = canvas.height;

            // ËÉåÊôØ„ÇØ„É™„Ç¢
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);

            const timeSlices = spectrogramData.length;
            const freqBins = spectrogramData[0].length;

            const sliceWidth = width / timeSlices;
            const binHeight = height / freqBins;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†ÊèèÁîª
            for (let t = 0; t < timeSlices; t++) {
                const x = t * sliceWidth;

                for (let f = 0; f < freqBins; f++) {
                    const y = height - (f + 1) * binHeight; // Âë®Ê≥¢Êï∞„ÇíÂèçËª¢
                    const amplitude = spectrogramData[t][f];

                    if (amplitude > 10) { // „Éé„Ç§„Ç∫„Éï„Ç£„É´„Çø
                        // Chrome Music LabÈ¢®„Ç´„É©„Éº„Éû„ÉÉ„Éî„É≥„Ç∞
                        const normalizedAmp = amplitude / 255.0;
                        const hue = 360 - (normalizedAmp * 360); // 360Â∫¶„Åã„Çâ0Â∫¶„Å∏
                        const [r, g, b] = hsvToRgb(hue, 1.0, normalizedAmp);

                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, y, sliceWidth + 1, binHeight + 1);
                    }
                }
            }

            // „Éï„Ç©„É´„Éû„É≥„ÉàÁ∑ö„ÇíÊèèÁîª
            if (currentF1 > 0 && currentF2 > 0) {
                const maxFreq = 4000; // Ë°®Á§∫„Åô„ÇãÊúÄÂ§ßÂë®Ê≥¢Êï∞

                // F1Á∑ö (Ëµ§)
                const f1Y = height - (currentF1 / maxFreq) * height;
                if (f1Y > 0 && f1Y < height) {
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, f1Y);
                    ctx.lineTo(width, f1Y);
                    ctx.stroke();

                    // F1„É©„Éô„É´
                    ctx.fillStyle = '#ff4444';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`F1: ${currentF1}Hz`, width - 120, f1Y - 5);
                }

                // F2Á∑ö (ÈªÑ)
                const f2Y = height - (currentF2 / maxFreq) * height;
                if (f2Y > 0 && f2Y < height) {
                    ctx.strokeStyle = '#ffff44';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, f2Y);
                    ctx.lineTo(width, f2Y);
                    ctx.stroke();

                    // F2„É©„Éô„É´
                    ctx.fillStyle = '#ffff44';
                    ctx.font = 'bold 14px Arial';
                    ctx.fillText(`F2: ${currentF2}Hz`, width - 120, f2Y - 5);
                }

                // Á∑ö„Çπ„Çø„Ç§„É´„Çí„É™„Çª„ÉÉ„Éà
                ctx.setLineDash([]);
            }

            // ÊØçÈü≥„Éû„Éº„Ç´„ÉºÔºàÁêÜÊÉ≥ÁöÑ„Å™„Éï„Ç©„É´„Éû„É≥„Éà‰ΩçÁΩÆÔºâ
            const targetVowel = ENGLISH_VOWELS[currentVowel];
            if (targetVowel) {
                const maxFreq = 4000;
                const targetF1Y = height - (targetVowel.f1 / maxFreq) * height;
                const targetF2Y = height - (targetVowel.f2 / maxFreq) * height;

                if (targetF1Y > 0 && targetF1Y < height) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2, 8]);
                    ctx.beginPath();
                    ctx.moveTo(0, targetF1Y);
                    ctx.lineTo(width, targetF1Y);
                    ctx.stroke();

                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Target F1: ${targetVowel.f1}Hz`, 10, targetF1Y - 5);
                }

                if (targetF2Y > 0 && targetF2Y < height) {
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([2, 8]);
                    ctx.beginPath();
                    ctx.moveTo(0, targetF2Y);
                    ctx.lineTo(width, targetF2Y);
                    ctx.stroke();

                    ctx.fillStyle = '#00ff88';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Target F2: ${targetVowel.f2}Hz`, 10, targetF2Y - 5);
                }

                ctx.setLineDash([]);
            }

            // „Éï„É¨„Éº„É†ÊÉÖÂ†±Ë°®Á§∫
            ctx.fillStyle = '#00ff88';
            ctx.font = '12px monospace';
            ctx.fillText(`Frames: ${timeSlices}, Freq bins: ${freqBins}`, 10, height - 10);
        }

        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞„Å´„Éï„Ç©„É´„Éû„É≥„ÉàÂÄ§„ÇíËøΩÂä†
        let currentF1 = 0, currentF2 = 0;

        // MFCCË®àÁÆóÈñ¢Êï∞ÔºàÁ∞°ÊòìÁâàÔºâ
        function calculateMFCC(frequencyData, numCoeffs = 13) {
            // „É°„É´„Éï„Ç£„É´„Çø„Éº„Éê„É≥„ÇØÁîüÊàê
            function createMelFilterBank(numFilters, fftSize, sampleRate) {
                const melFilters = [];
                const nyquist = sampleRate / 2;

                // „É°„É´Â§âÊèõÈñ¢Êï∞
                const hzToMel = (hz) => 2595 * Math.log10(1 + hz / 700);
                const melToHz = (mel) => 700 * (Math.pow(10, mel / 2595) - 1);

                const melMin = hzToMel(0);
                const melMax = hzToMel(nyquist);
                const melPoints = [];

                // „É°„É´Âàª„ÅøÁÇπÁîüÊàê
                for (let i = 0; i <= numFilters + 1; i++) {
                    melPoints.push(melMin + i * (melMax - melMin) / (numFilters + 1));
                }

                // HzÂ§âÊèõ
                const hzPoints = melPoints.map(melToHz);
                const binPoints = hzPoints.map(hz => Math.floor((fftSize + 1) * hz / nyquist));

                // ‰∏âËßí„Éï„Ç£„É´„ÇøÁîüÊàê
                for (let i = 1; i <= numFilters; i++) {
                    const filter = new Array(Math.floor(fftSize / 2) + 1).fill(0);

                    // Â∑¶„ÅÆÂÇæÊñú
                    for (let k = binPoints[i-1]; k < binPoints[i]; k++) {
                        if (k < filter.length) {
                            filter[k] = (k - binPoints[i-1]) / (binPoints[i] - binPoints[i-1]);
                        }
                    }

                    // Âè≥„ÅÆÂÇæÊñú
                    for (let k = binPoints[i]; k < binPoints[i+1]; k++) {
                        if (k < filter.length) {
                            filter[k] = (binPoints[i+1] - k) / (binPoints[i+1] - binPoints[i]);
                        }
                    }

                    melFilters.push(filter);
                }

                return melFilters;
            }

            // DCTÂ§âÊèõÔºàType-IIÔºâ
            function dct(signal) {
                const N = signal.length;
                const result = new Array(N);

                for (let k = 0; k < N; k++) {
                    let sum = 0;
                    for (let n = 0; n < N; n++) {
                        sum += signal[n] * Math.cos((Math.PI * k * (2 * n + 1)) / (2 * N));
                    }
                    result[k] = sum;
                }

                return result;
            }

            // „Éë„ÉØ„Éº„Çπ„Éö„ÇØ„Éà„É©„É†Ë®àÁÆóÔºàÁ∞°ÊòìÁâàÔºâ
            const powerSpectrum = new Array(Math.floor(frequencyData.length / 2));
            for (let i = 0; i < powerSpectrum.length; i++) {
                const magnitude = frequencyData[i] / 255.0; // Ê≠£Ë¶èÂåñ
                powerSpectrum[i] = magnitude * magnitude; // „Éë„ÉØ„Éº
            }

            // „É°„É´„Éï„Ç£„É´„Çø„Éº„Éê„É≥„ÇØÈÅ©Áî®
            const melFilters = createMelFilterBank(26, frequencyData.length * 2, audioContext.sampleRate);
            const melEnergies = [];

            for (const filter of melFilters) {
                let energy = 0;
                for (let i = 0; i < Math.min(powerSpectrum.length, filter.length); i++) {
                    energy += powerSpectrum[i] * filter[i];
                }
                melEnergies.push(Math.log(Math.max(energy, 1e-10))); // „É≠„Ç∞Â§âÊèõ
            }

            // DCTÈÅ©Áî®„Åó„Å¶MFCCÂèñÂæó
            const mfccFull = dct(melEnergies);
            const mfcc = mfccFull.slice(0, numCoeffs);

            return mfcc;
        }

        function drawMFCCPlot() {
            if (!mfccCtx) return;

            const width = mfccCanvas.width;
            const height = mfccCanvas.height;

            // ËÉåÊôØ„ÇØ„É™„Ç¢Ôºà„Çà„Çä„ÇΩ„Éï„Éà„Å™„Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥Ôºâ
            const gradient = mfccCtx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, 'rgba(5, 5, 15, 0.95)');
            gradient.addColorStop(1, 'rgba(10, 10, 25, 0.95)');
            mfccCtx.fillStyle = gradient;
            mfccCtx.fillRect(0, 0, width, height);

            // ÁõÆÊ®ôÊØçÈü≥„ÅÆMFCCÂèñÂæó
            const targetVowel = ENGLISH_VOWELS[currentVowel];
            const targetMFCC = targetVowel ? targetVowel.mfcc : [];

            if (targetMFCC.length === 0) {
                // „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºË°®Á§∫ÔºàÊîπËâØÔºâ
                mfccCtx.fillStyle = '#555';
                mfccCtx.font = 'bold 14px Arial';
                mfccCtx.textAlign = 'center';
                mfccCtx.fillText('üé§ Start recording to see MFCC comparison', width / 2, height / 2);

                mfccCtx.fillStyle = '#777';
                mfccCtx.font = '12px Arial';
                mfccCtx.fillText(`Target: ${currentVowel} (${targetVowel?.name || ''})`, width / 2, height / 2 + 20);
                return;
            }

            // ‰ΩøÁî®„Åô„ÇãMFCCÊï∞ÔºàÊúÄÂ§ß13Ôºâ
            const numCoeffs = Math.max(currentMFCC.length, targetMFCC.length, 13);
            const barWidth = (width - 20) / numCoeffs; // „Éû„Éº„Ç∏„É≥ËøΩÂä†
            const centerY = height / 2;

            // Ê≠£Ë¶èÂåñÁî®„ÅÆÊúÄÂ§ßÂÄ§Ë®àÁÆóÔºàTarget MFCC„ÅØÂõ∫ÂÆö„Çπ„Ç±„Éº„É´„ÄÅCurrent MFCC„ÅØÂãïÁöÑ„Çπ„Ç±„Éº„É´Ôºâ
            const targetMaxVal = Math.max(...targetMFCC.map(Math.abs), 1);
            const currentMaxVal = currentMFCC.length > 0 ? Math.max(...currentMFCC.map(Math.abs), 1) : 1;

            // „Ç∞„É™„ÉÉ„ÉâÁ∑öÊèèÁîª
            mfccCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            mfccCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (height - 40) * i / 4 + 20;
                mfccCtx.beginPath();
                mfccCtx.moveTo(10, y);
                mfccCtx.lineTo(width - 10, y);
                mfccCtx.stroke();
            }

            for (let i = 0; i < numCoeffs; i++) {
                const x = 10 + i * barWidth;

                // ÁõÆÊ®ôMFCCÔºà„Ç¢„Ç¶„Éà„É©„Ç§„É≥Ë°®Á§∫„ÅßË¶ã„ÇÑ„Åô„ÅèÔºâ
                if (targetMFCC[i] !== undefined) {
                    const targetNormalized = targetMFCC[i] / targetMaxVal;
                    const targetBarHeight = Math.abs(targetNormalized) * (height / 2 - 30);

                    // ÂΩ±ÂäπÊûú
                    mfccCtx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    if (targetNormalized >= 0) {
                        mfccCtx.fillRect(x + 2, centerY - targetBarHeight + 2, barWidth - 4, targetBarHeight);
                    } else {
                        mfccCtx.fillRect(x + 2, centerY + 2, barWidth - 4, targetBarHeight);
                    }

                    // „É°„Ç§„É≥„Éê„ÉºÔºàÁõÆÊ®ôÔºâ
                    mfccCtx.fillStyle = 'rgba(0, 255, 136, 0.4)';
                    if (targetNormalized >= 0) {
                        mfccCtx.fillRect(x, centerY - targetBarHeight, barWidth - 4, targetBarHeight);
                    } else {
                        mfccCtx.fillRect(x, centerY, barWidth - 4, targetBarHeight);
                    }

                    // „Ç¢„Ç¶„Éà„É©„Ç§„É≥
                    mfccCtx.strokeStyle = '#00ff88';
                    mfccCtx.lineWidth = 1.5;
                    mfccCtx.setLineDash([3, 2]);
                    mfccCtx.strokeRect(x, targetNormalized >= 0 ? centerY - targetBarHeight : centerY,
                                     barWidth - 4, targetBarHeight);
                    mfccCtx.setLineDash([]);
                }

                // ÁèæÂú®„ÅÆMFCCÔºà„Çà„ÇäÈÆÆÊòé„Å™Ë°®Á§∫Ôºâ
                if (currentMFCC[i] !== undefined) {
                    const currentNormalized = currentMFCC[i] / currentMaxVal;
                    const currentBarHeight = Math.abs(currentNormalized) * (height / 2 - 30);

                    // „Ç∞„É≠„ÉºÂäπÊûú
                    const glowGradient = mfccCtx.createLinearGradient(x, centerY - currentBarHeight, x, centerY + currentBarHeight);

                    if (currentNormalized >= 0) {
                        // Ê≠£„ÅÆÂÄ§Ôºà‰∏äÂêë„ÅçÔºâ
                        glowGradient.addColorStop(0, '#ff6622');
                        glowGradient.addColorStop(1, '#ff8844');
                        mfccCtx.fillStyle = glowGradient;
                        mfccCtx.fillRect(x + 2, centerY - currentBarHeight, barWidth - 8, currentBarHeight);
                    } else {
                        // Ë≤†„ÅÆÂÄ§Ôºà‰∏ãÂêë„ÅçÔºâ
                        glowGradient.addColorStop(0, '#2266ff');
                        glowGradient.addColorStop(1, '#4488ff');
                        mfccCtx.fillStyle = glowGradient;
                        mfccCtx.fillRect(x + 2, centerY, barWidth - 8, currentBarHeight);
                    }

                    // „Éè„Ç§„É©„Ç§„ÉàÂäπÊûú
                    mfccCtx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    if (currentNormalized >= 0) {
                        mfccCtx.fillRect(x + 2, centerY - currentBarHeight, (barWidth - 8) / 3, currentBarHeight);
                    } else {
                        mfccCtx.fillRect(x + 2, centerY, (barWidth - 8) / 3, currentBarHeight);
                    }
                }

                // MFCC‰øÇÊï∞Áï™Âè∑Ë°®Á§∫ÔºàÊîπËâØÔºâ
                mfccCtx.fillStyle = i % 2 === 0 ? '#ddd' : '#999';
                mfccCtx.font = 'bold 9px Arial';
                mfccCtx.textAlign = 'center';
                mfccCtx.fillText(i.toString(), x + barWidth / 2, height - 8);

                // ÈáçË¶Å„Å™‰øÇÊï∞„Å´„Éû„Éº„ÇØ
                if (i < 3) {
                    mfccCtx.fillStyle = '#ffff00';
                    mfccCtx.font = '8px Arial';
                    mfccCtx.fillText('‚òÖ', x + barWidth / 2, height - 18);
                }
            }

            // ‰∏≠Â§ÆÁ∑öÔºàÊîπËâØÔºâ
            mfccCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            mfccCtx.lineWidth = 2;
            mfccCtx.beginPath();
            mfccCtx.moveTo(10, centerY);
            mfccCtx.lineTo(width - 10, centerY);
            mfccCtx.stroke();

            // Ëª∏„É©„Éô„É´ÔºàÊîπËâØÔºâ
            mfccCtx.fillStyle = '#ccc';
            mfccCtx.font = 'bold 11px Arial';
            mfccCtx.textAlign = 'left';
            mfccCtx.fillText('MFCC Coefficients (‚òÖ = Important)', 10, height - 25);

            // Âá°‰æãÔºàÊîπËâØ„Åï„Çå„Åü„É¨„Ç§„Ç¢„Ç¶„ÉàÔºâ
            const legendY = 10;
            mfccCtx.textAlign = 'right';

            // ÁèæÂú®„ÅÆÂÄ§
            mfccCtx.fillStyle = '#ff8844';
            mfccCtx.fillRect(width - 100, legendY, 12, 10);
            mfccCtx.fillStyle = 'white';
            mfccCtx.font = 'bold 11px Arial';
            mfccCtx.fillText('Your Voice', width - 85, legendY + 8);

            // ÁõÆÊ®ôÂÄ§
            mfccCtx.strokeStyle = '#00ff88';
            mfccCtx.lineWidth = 1.5;
            mfccCtx.setLineDash([3, 2]);
            mfccCtx.strokeRect(width - 100, legendY + 15, 12, 10);
            mfccCtx.setLineDash([]);
            mfccCtx.fillStyle = 'rgba(0, 255, 136, 0.4)';
            mfccCtx.fillRect(width - 100, legendY + 15, 12, 10);
            mfccCtx.fillStyle = '#00ff88';
            mfccCtx.fillText(`Target: ${currentVowel} (${targetVowel?.name || ''})`, width - 85, legendY + 23);

            // È°û‰ººÂ∫¶Ë®àÁÆó„Å®Ë°®Á§∫ÔºàÊîπËâØÔºâ
            if (currentMFCC.length > 0 && targetMFCC.length > 0) {
                let similarity = calculateMFCCSimilarity(currentMFCC, targetMFCC);

                // È°û‰ººÂ∫¶„Éú„ÉÉ„ÇØ„Çπ
                const simY = legendY + 35;
                const simBoxWidth = 80;

                // ËÉåÊôØ„Éú„ÉÉ„ÇØ„Çπ
                mfccCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                mfccCtx.fillRect(width - simBoxWidth - 10, simY, simBoxWidth, 20);

                // È°û‰ººÂ∫¶„Éê„Éº
                const barFillWidth = (simBoxWidth - 10) * similarity;
                const simColor = similarity > 0.8 ? '#00ff88' : (similarity > 0.6 ? '#ffff44' : '#ff4444');
                mfccCtx.fillStyle = simColor;
                mfccCtx.fillRect(width - simBoxWidth - 5, simY + 3, barFillWidth, 6);

                // È°û‰ººÂ∫¶„ÉÜ„Ç≠„Çπ„Éà
                mfccCtx.fillStyle = 'white';
                mfccCtx.font = 'bold 10px Arial';
                mfccCtx.textAlign = 'center';
                mfccCtx.fillText(`${(similarity * 100).toFixed(0)}%`, width - simBoxWidth/2 - 10, simY + 15);

                // „É©„Éô„É´
                mfccCtx.fillStyle = '#ccc';
                mfccCtx.font = '9px Arial';
                mfccCtx.fillText('Similarity', width - simBoxWidth/2 - 10, simY - 2);

                // Ë©ï‰æ°„É°„ÉÉ„Çª„Éº„Ç∏
                const message = similarity > 0.85 ? 'üéØ Excellent!' :
                              similarity > 0.7 ? 'üëç Good!' :
                              similarity > 0.5 ? 'üìà Keep trying!' : 'üí™ Practice more!';
                mfccCtx.fillStyle = simColor;
                mfccCtx.font = 'bold 10px Arial';
                mfccCtx.textAlign = 'right';
                mfccCtx.fillText(message, width - 5, height - 40);
            }

            // ÂÄ§„ÅÆË°®Á§∫ÔºàÊï∞ÂÄ§Ôºâ
            if (targetMFCC.length > 0 || currentMFCC.length > 0) {
                mfccCtx.fillStyle = '#666';
                mfccCtx.font = '8px monospace';
                mfccCtx.textAlign = 'right';
                mfccCtx.fillText(`Target Max: ${targetMaxVal.toFixed(1)}`, width - 5, height - 65);
                if (currentMFCC.length > 0) {
                    mfccCtx.fillText(`Current Max: ${currentMaxVal.toFixed(1)}`, width - 5, height - 55);
                }
            }
        }

        function calculateMFCCSimilarity(current, target) {
            if (!current || !target || current.length === 0 || target.length === 0) {
                return 0;
            }

            // „Ç≥„Çµ„Ç§„É≥È°û‰ººÂ∫¶Ë®àÁÆó
            let dotProduct = 0;
            let normCurrent = 0;
            let normTarget = 0;

            const minLength = Math.min(current.length, target.length);

            for (let i = 0; i < minLength; i++) {
                dotProduct += current[i] * target[i];
                normCurrent += current[i] * current[i];
                normTarget += target[i] * target[i];
            }

            const denominator = Math.sqrt(normCurrent) * Math.sqrt(normTarget);
            if (denominator === 0) return 0;

            const similarity = dotProduct / denominator;
            return Math.max(0, (similarity + 1) / 2); // -1~1„Çí0~1„Å´Ê≠£Ë¶èÂåñ
        }

        function extractFormants(dataArray) {
            // „Çà„ÇäÈ´òÁ≤æÂ∫¶„Å™„Éï„Ç©„É´„Éû„É≥„ÉàÊé®ÂÆö
            const sampleRate = audioContext.sampleRate;
            const binSize = sampleRate / (2 * dataArray.length);

            // „Çπ„É†„Éº„Ç∏„É≥„Ç∞Âá¶ÁêÜ
            const smoothedData = new Float32Array(dataArray.length);
            for (let i = 1; i < dataArray.length - 1; i++) {
                smoothedData[i] = (dataArray[i-1] + dataArray[i] * 2 + dataArray[i+1]) / 4;
            }

            // „Éî„Éº„ÇØÊ§úÂá∫Èñ¢Êï∞
            function findPeaks(data, minAmplitude = 20) {
                const peaks = [];
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > minAmplitude) {
                        peaks.push({
                            index: i,
                            frequency: i * binSize,
                            amplitude: data[i]
                        });
                    }
                }
                return peaks.sort((a, b) => b.amplitude - a.amplitude);
            }

            const peaks = findPeaks(smoothedData);

            // F1ÂÄôË£ú (200-1000Hz)
            const f1Candidates = peaks.filter(p =>
                p.frequency >= 200 && p.frequency <= 1000
            );

            // F2ÂÄôË£ú (800-3000Hz) - F1„Çà„ÇäÈ´ò„ÅÑÂë®Ê≥¢Êï∞
            const f2Candidates = peaks.filter(p =>
                p.frequency >= 800 && p.frequency <= 3000
            );

            // ÊúÄ„ÇÇÂº∑„ÅÑ„Éî„Éº„ÇØ„ÇíÈÅ∏Êäû
            let f1 = f1Candidates.length > 0 ? f1Candidates[0].frequency : 0;
            let f2 = f2Candidates.find(p => p.frequency > f1)?.frequency || 0;

            // „Éï„Ç©„É´„Éû„É≥„ÉàËøΩË∑°ÔºàÊÄ•ÊøÄ„Å™Â§âÂåñ„ÇíÊäëÂà∂Ôºâ
            const smoothingFactor = 0.7;
            if (f1 > 0) {
                currentF1 = currentF1 === 0 ? f1 : currentF1 * smoothingFactor + f1 * (1 - smoothingFactor);
            }
            if (f2 > 0) {
                currentF2 = currentF2 === 0 ? f2 : currentF2 * smoothingFactor + f2 * (1 - smoothingFactor);
            }

            return { f1: Math.round(currentF1), f2: Math.round(currentF2) };
        }

        function classifyVowel(dataArray) {
            // „Éï„Ç©„É´„Éû„É≥„ÉàÊé®ÂÆö
            const formants = extractFormants(dataArray);

            // MFCCË®àÁÆó
            try {
                currentMFCC = calculateMFCC(dataArray, 13);
            } catch (error) {
                console.warn('MFCC calculation failed:', error);
                currentMFCC = [];
            }

            // UIÊõ¥Êñ∞
            document.getElementById('f1Value').textContent = formants.f1 || '-';
            document.getElementById('f2Value').textContent = formants.f2 || '-';

            // ÊØçÈü≥ÂàÜÈ°û
            if (formants.f1 > 0 && formants.f2 > 0) {
                let bestMatch = '…ô';
                let minDistance = Infinity;

                for (const [vowel, data] of Object.entries(ENGLISH_VOWELS)) {
                    const distance = Math.sqrt(
                        Math.pow(formants.f1 - data.f1, 2) + Math.pow(formants.f2 - data.f2, 2)
                    );
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestMatch = vowel;
                    }
                }

                const isMatch = bestMatch === currentVowel;
                const confidence = Math.max(0, 100 - Math.round(minDistance / 10));

                document.getElementById('detectedVowel').textContent =
                    `${bestMatch} (${ENGLISH_VOWELS[bestMatch].name})${isMatch ? ' ‚úÖ' : ''} ${confidence}%`;
            } else {
                document.getElementById('detectedVowel').textContent = 'No clear vowel detected';
            }

            return formants;
        }

        function drawFormantPlot() {
            if (!formantCtx) return;

            const width = formantCanvas.width;
            const height = formantCanvas.height;

            // ËÉåÊôØ„ÇØ„É™„Ç¢
            formantCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            formantCtx.fillRect(0, 0, width, height);

            // F1-F2Á©∫Èñì„ÅÆÁØÑÂõ≤Ë®≠ÂÆö
            const f1Min = 200, f1Max = 1000;
            const f2Min = 500, f2Max = 3000;

            // Â∫ßÊ®ôÂ§âÊèõÈñ¢Êï∞
            function toPlotCoords(f1, f2) {
                const x = ((f2 - f2Min) / (f2Max - f2Min)) * width;
                const y = height - ((f1 - f1Min) / (f1Max - f1Min)) * height;
                return { x, y };
            }

            // Ëª∏„ÅÆÊèèÁîª
            formantCtx.strokeStyle = '#444';
            formantCtx.lineWidth = 1;
            formantCtx.setLineDash([]);

            // „Ç∞„É™„ÉÉ„Éâ
            for (let f2 = 1000; f2 <= 2500; f2 += 500) {
                const x = ((f2 - f2Min) / (f2Max - f2Min)) * width;
                formantCtx.beginPath();
                formantCtx.moveTo(x, 0);
                formantCtx.lineTo(x, height);
                formantCtx.stroke();
            }

            for (let f1 = 300; f1 <= 900; f1 += 200) {
                const y = height - ((f1 - f1Min) / (f1Max - f1Min)) * height;
                formantCtx.beginPath();
                formantCtx.moveTo(0, y);
                formantCtx.lineTo(width, y);
                formantCtx.stroke();
            }

            // ÁêÜÊÉ≥ÁöÑ„Å™ÊØçÈü≥‰ΩçÁΩÆ„ÇíÊèèÁîª
            for (const [vowel, data] of Object.entries(ENGLISH_VOWELS)) {
                const coords = toPlotCoords(data.f1, data.f2);
                if (coords.x >= 0 && coords.x <= width && coords.y >= 0 && coords.y <= height) {
                    // ÊØçÈü≥ÂÜÜ
                    formantCtx.fillStyle = vowel === currentVowel ? '#00ff88' : data.color;
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, vowel === currentVowel ? 8 : 4, 0, Math.PI * 2);
                    formantCtx.fill();

                    // ÊØçÈü≥„É©„Éô„É´
                    formantCtx.fillStyle = 'white';
                    formantCtx.font = '10px Arial';
                    formantCtx.textAlign = 'center';
                    formantCtx.fillText(vowel, coords.x, coords.y - 10);
                }
            }

            // ÁèæÂú®„ÅÆÁô∫Ë©±‰ΩçÁΩÆ„ÇíÊèèÁîª
            if (currentF1 > 0 && currentF2 > 0) {
                const coords = toPlotCoords(currentF1, currentF2);
                if (coords.x >= 0 && coords.x <= width && coords.y >= 0 && coords.y <= height) {
                    // ÁèæÂú®‰ΩçÁΩÆ„Éû„Éº„Ç´„Éº
                    formantCtx.fillStyle = '#ff4444';
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, 6, 0, Math.PI * 2);
                    formantCtx.fill();

                    // Ëº™ÈÉ≠
                    formantCtx.strokeStyle = 'white';
                    formantCtx.lineWidth = 2;
                    formantCtx.beginPath();
                    formantCtx.arc(coords.x, coords.y, 6, 0, Math.PI * 2);
                    formantCtx.stroke();
                }
            }

            // Ëª∏„É©„Éô„É´
            formantCtx.fillStyle = 'white';
            formantCtx.font = '10px Arial';
            formantCtx.textAlign = 'center';
            formantCtx.fillText('F2 (Hz)', width / 2, height - 5);

            formantCtx.save();
            formantCtx.translate(10, height / 2);
            formantCtx.rotate(-Math.PI / 2);
            formantCtx.fillText('F1 (Hz)', 0, 0);
            formantCtx.restore();
        }

        // updateSpectrogramÈñ¢Êï∞„Çí‰øÆÊ≠£„Åó„Å¶„Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„Éà„ÇÇÊõ¥Êñ∞
        function updateSpectrogram() {
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Èü≥Â£∞„É¨„Éô„É´Ë®àÁÆó
            let sum = 0;
            let maxVal = 0;
            let maxIndex = 0;

            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
                if (dataArray[i] > maxVal) {
                    maxVal = dataArray[i];
                    maxIndex = i;
                }
            }

            const avgLevel = Math.round(sum / bufferLength);
            const peakFreq = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));

            // UIÊõ¥Êñ∞
            document.getElementById('audioLevel').textContent = avgLevel;
            document.getElementById('freqPeak').textContent = peakFreq;
            document.getElementById('debugInfo').textContent =
                `Debug: Level=${avgLevel}, Peak=${peakFreq}Hz, Max=${maxVal}`;

            // „Çπ„Éö„ÇØ„Éà„É≠„Ç∞„É©„É†„Éá„Éº„Çø„Å´ËøΩÂä†
            spectrogramData.push(Array.from(dataArray));

            // Â±•Ê≠¥Âà∂Èôê
            if (spectrogramData.length > maxSpectrogramHistory) {
                spectrogramData.shift();
            }

            // Á∞°ÊòìÊØçÈü≥ÂàÜÈ°û„Å®„Éï„Ç©„É´„Éû„É≥„Éà„Éó„É≠„ÉÉ„ÉàÊõ¥Êñ∞
            classifyVowel(dataArray);
            drawFormantPlot();
            drawMFCCPlot();
        }

        // ÂàùÊúüÂåñÂÆüË°å
        window.addEventListener('load', init);
    </script>
</body>
</html>
